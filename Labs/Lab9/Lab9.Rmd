---
title: 'Jonathan, Environmental Data Science @UIUC. Lab 9 - Watershed analysis'
date: "3/25/2024"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Overview

In this lab, you will practice watershed analysis in R using a DEM file downloaded by yourself.

As a preparation, please go through the exercise under Canvas module > Week 11 > Watershed-analysis-tutorial-updated.html/rmd, and understand the purpose and meaning of each script line. 

Then, replicate the entire watershed analysis process as described in Watershed-analysis-tutorial-updated.html using a DEM tile covering your own region of interest (e.g., part of the Rocky Mountain, Flint Hills, or Central Illinois) in the US. In other words, you will need to download your own DEM, instead of using the DEM available in the spDataLarge package.

One platform to download high-resolution national DEM is The National Map (TNM) Download Apps: https://apps.nationalmap.gov/downloader. 

Once you are on the TNM webpage, zoom to your area of interest using the interactive map, and then further refine your region using the "Extent", "Polygon", or "Point" option after "Area of Interest". 

Then, check "Elevation Products (3DEP)" and select the DEM with your preferred spatial resolution (e.g., 1/3 arc-second, which is about ~10 m). Think about what resolution will serve your purpose (note: very high-resolution DEM is not always necessary). 

Under "File Formats", check the GeoTIFF format (.tif).

After the region is defined and the DEM and the file format are specified, click on "Search Products". The DEM tiles satisfying your search criteria will be returned. If multiple files are returned, you will need to download only ONE of them for the purpose of this lab. You can click on "Footprint" to see where the DEM tile covers. Once you have decided which tile to download, click on "Download Link (TIF)", and the DEM tile will be downloaded to your computer. 

Now you have your own DEM! Congrats! And you are ready to continue following the procedure described in Watershed-analysis-tutorial-updated.html. 

Submission: A fully commented and formatted R Markdown file that replicates each of the steps in the entire watershed analysis as described in Watershed-analysis-tutorial-updated.rmd but based on your downloaded DEM.

To start: load the packages and define the variable environments as below...

```{r setup-libraries}
#install.packages("rgl")
library(tidyverse)
library(raster)
library(sf)
library(tmap)
library(stars)
library(rgl)
library(terra)
library(dplyr)
library(spData)
library(spDataLarge)

#install.packages("rayshader")
library(rayshader) 

#install.packages("whitebox", repos = "http://R-Forge.R-project.org")
#install.packages("whitebox")
whitebox::install_whitebox()
library(whitebox)
```

```{r environment-setup, warning=FALSE, message=FALSE}
# Set working directory to location of DEM.tif file
my_directory <- "/Users/jonathanbernard/Desktop/UIUC/Spring 2024/GGIS 224/GGIS224/Labs/Lab9"
setwd(my_directory)

# Read the DEM
dem = rast("dem.tif")

# Set the CRS of the DEM to WGS 84 / UTM zone 15N
crs(dem) <- "EPSG:32615"

# Visualize the DEM
tmap_mode("view")
if (ncol(dem) < 1000 & nrow(dem) < 1000) {
  tm_shape(dem) +
    tm_raster(style = "cont", palette = "PuOr", legend.show = TRUE) +
    tm_scale_bar()
} else {
  tm_shape(aggregate(dem, 10), raster.downsample = TRUE) +
    tm_raster(style = "cont", palette = "PuOr", legend.show = TRUE) +
    tm_scale_bar()
}

# Generate hillshade
wbt_hillshade(dem = paste0(my_directory, "/dem.tif"), output = paste0(my_directory, "/hillshade.tif"), azimuth = 300)
hillshade = raster("hillshade.tif")

# Map the hillshade
if (ncol(hillshade) < 1000 & nrow(hillshade) < 1000) {
  tm_shape(hillshade) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_scale_bar()
} else {
  tm_shape(aggregate(hillshade, 10), raster.downsample = TRUE) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_scale_bar()
}

# Fill and breach the DEM
wbt_fill_single_cell_pits(dem = paste0(my_directory, "/dem.tif"), output = paste0(my_directory, "/dem_filled.tif"))
wbt_breach_depressions_least_cost(dem = paste0(my_directory, "/dem_filled.tif"), output = paste0(my_directory, "/dem_breached.tif"), dist = 5, fill = TRUE)
wbt_fill_depressions_wang_and_liu(dem = paste0(my_directory, "/dem_breached.tif"), output = paste0(my_directory, "/dem_filled_breached.tif"))

# Read the smoothed DEM
dem = rast("dem_filled_breached.tif")

# Map the DEM
if (ncol(dem) < 1000 & nrow(dem) < 1000) {
  tm_shape(dem) +
    tm_raster(style = "cont", palette = "PuOr", legend.show = TRUE) +
    tm_scale_bar()
} else {
  tm_shape(aggregate(dem, 10), raster.downsample = TRUE) +
    tm_raster(style = "cont", palette = "PuOr", legend.show = TRUE) +
    tm_scale_bar()
}

# Generate flow accumulation and flow direction maps
wbt_d8_flow_accumulation(input = paste0(my_directory, "/dem_filled_breached.tif"), output = paste0(my_directory, "/D8FA.tif"))
wbt_d8_flow_accumulation_lyr = rast("D8FA.tif")

# Visualize the flow accumulation map
if (ncol(wbt_d8_flow_accumulation_lyr) < 1000 & nrow(wbt_d8_flow_accumulation_lyr) < 1000) {
  tm_shape(wbt_d8_flow_accumulation_lyr) +
    tm_raster(style = "quantile", legend.show = TRUE) +
    tm_scale_bar()
} else {
  tm_shape(aggregate(wbt_d8_flow_accumulation_lyr, 10), raster.downsample = TRUE) +
    tm_raster(style = "quantile", legend.show = TRUE) +
    tm_scale_bar()
}

# Generate the flow direction (pointer) map
wbt_d8_pointer(dem = paste0(my_directory, "/dem_filled_breached.tif"), output = paste0(my_directory, "/D8pointer.tif"))
wbt_d8_pointer_lyr = rast("D8pointer.tif")

# Visualize the flow direction map
if (ncol(wbt_d8_pointer_lyr) < 1000 & nrow(wbt_d8_pointer_lyr) < 1000) {
  tm_shape(wbt_d8_pointer_lyr) +
    tm_raster(style = "cont", legend.show = TRUE) +
    tm_scale_bar()
} else {
  tm_shape(aggregate(wbt_d8_pointer_lyr, 10, fun = modal), raster.downsample = TRUE) +
    tm_raster(style = "cont", legend.show = TRUE) +
    tm_scale_bar()
}

# Set pour points
ppoints <- tribble(
  ~Lon, ~Lat,
  -91.984427, 40.718717,
  -91.384747, 40.591037,
)

# Create dataframe with pour points
ppointsSP <- SpatialPoints(ppoints, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Convert data frame to shapefile and write the shapefile to our data directory
shapefile(ppointsSP, filename = "pourpoints.shp", overwrite = TRUE)

# Read the shapefile
ppointsSP_gcs = st_read("pourpoints.shp")

# Transform the spatial coordinate system of the pour point shapefile to the same one used by the filled DEM
st_crs(dem)
ppointsSP_prj = st_transform(ppointsSP_gcs, crs = "EPSG:32615")
st_write(ppointsSP_prj, "ppointsSP_prj.shp", layer_options = 'OVERWRITE=YES', update = TRUE)

# Create a raster stream grid
wbt_extract_streams(flow_accum = paste0(my_directory, "/D8FA.tif"), output = paste0(my_directory, "/raster_streams.tif"), threshold = 50)

# Snap pour points to stream network
wbt_jenson_snap_pour_points(pour_pts = paste0(my_directory, "/ppointsSP_prj.shp"), streams = paste0(my_directory, "/raster_streams.tif"), output = paste0(my_directory, "/snappedpp.shp"), snap_dist = 150)

# Read the produced files
streams <- raster("raster_streams.tif")
pp = shapefile("snappedpp.shp")

# Visualize the pour points before and after being snapped to the network
if (ncol(streams) < 1000 & nrow(streams) < 1000) {
  tm_shape(streams) +
    tm_raster(legend.show = TRUE, palette = "Blues") +
    tm_shape(ppointsSP_prj) +
    tm_dots(col = "red")
} else {
  tm_shape(aggregate(streams, 10, fun = max), raster.downsample = TRUE) +
    tm_raster(legend.show = TRUE, palette = "Blues") +
    tm_shape(ppointsSP_prj) +
    tm_dots(col = "red")
}

if (ncol(streams) < 1000 & nrow(streams) < 1000) {
  tm_shape(streams) +
    tm_raster(legend.show = TRUE, palette = "Blues") +
    tm_shape(pp) +
    tm_dots(col = "red")
} else {
  tm_shape(aggregate(streams, 10, fun = max), raster.downsample = TRUE) +
    tm_raster(legend.show = TRUE, palette = "Blues") +
    tm_shape(pp) +
    tm_dots(col = "red")
}

# Delineate watersheds
wbt_watershed(d8_pntr = paste0(my_directory, "/D8pointer.tif"), pour_pts = paste0(my_directory, "/snappedpp.shp"), output = paste0(my_directory, "/watersheds.tif"))
ws = raster("watersheds.tif")

# Visualize the watersheds
if (ncol(hillshade) < 1000 & nrow(hillshade) < 1000) {
  tm_shape(hillshade) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_shape(ws) +
    tm_raster(legend.show = TRUE, alpha = 0.5, style = "cat") +
    tm_shape(pp) +
    tm_dots(col = "red")
} else {
  tm_shape(aggregate(hillshade, 10), raster.downsample = TRUE) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_shape(aggregate(ws, 10, fun = max), raster.downsample = TRUE) +
    tm_raster(legend.show = TRUE, alpha = 0.5, style = "cat") +
    tm_shape(pp) +
    tm_dots(col = "red")
}

# Convert watersheds to shapefiles
freq(ws)
wsshape = st_as_stars(ws) %>% st_as_sf(merge = T)
wsshape
wsshape_dissolved <- wsshape %>%
  group_by(watersheds) %>%
  summarise()

st_write(wsshape_dissolved, 'watersheds_shape.shp', layer_options = 'OVERWRITE=YES', update = TRUE)

# Visualize the vectorized watersheds
if (ncol(hillshade) < 1000 & nrow(hillshade) < 1000) {
  tm_shape(hillshade) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_shape(wsshape_dissolved) +
    tm_borders(col = "red")
} else {
  tm_shape(aggregate(hillshade, 10), raster.downsample = TRUE) +
    tm_raster(style = "cont", palette = "-Greys", legend.show = FALSE) +
    tm_shape(wsshape_dissolved) +
    tm_borders(col = "red")
}

# Extract and analyze data based on watershed boundaries
wsElevs <- extract(dem, wsshape_dissolved)

WS1 = filter(wsElevs, ID == 1)
WS2 = filter(wsElevs, ID == 2)

ggplot() +
  geom_density(as_tibble(WS1[,2]), mapping = aes(value, color = "WS1")) +
  geom_density(as_tibble(WS2[,2]), mapping = aes(value, color = "WS2")) +
  xlab("Elevation (meters above sea level)")
```